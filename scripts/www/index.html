<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ•°å­—è½¬çŒ«å¨˜ ^â€¢ï»Œâ€¢^à¸…</title>
    <style>
        body { font-family: 'Segoe UI', sans-serif; background: #f0f2f5; display: flex; flex-direction: column; align-items: center; padding: 20px; }
        .container { background: white; padding: 30px; border-radius: 12px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); width: 100%; max-width: 600px; text-align: center; }
        h1 { margin-bottom: 20px; color: #333; font-size: 24px; }
        .input-group { margin-bottom: 20px; display: flex; gap: 10px; justify-content: center; }
        input[type="text"] { padding: 10px; font-size: 16px; border: 2px solid #ddd; border-radius: 6px; outline: none; flex: 1; }
        select { padding: 10px; font-size: 16px; border: 2px solid #ddd; border-radius: 6px; width: 100px; }
        button { background: #4a90e2; color: white; border: none; padding: 10px 20px; font-size: 16px; border-radius: 6px; cursor: pointer; transition: 0.2s; }
        button:hover { background: #357abd; }
        button:disabled { background: #ccc; cursor: not-allowed; }
        
        /* é¢„è§ˆåŒºåŸŸæ ·å¼ */
        #preview-area { 
            margin-top: 20px; 
            min-height: 150px; 
            display: flex; 
            flex-direction: column; 
            justify-content: center; 
            align-items: center; 
            border: 2px dashed #ddd; 
            border-radius: 8px; 
            padding: 20px; 
            background: #fafafa; 
        }
        
        img.result { 
            max-width: 100%; 
            height: auto; 
            image-rendering: pixelated; 
            border-radius: 4px; 
            border: 1px solid #eee; 
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .status { margin-top: 15px; color: #666; font-size: 14px; line-height: 1.6; }
        .hint { color: #2196F3; font-weight: bold; margin-top: 10px; display: none; }
        
        .obfuscate-box { margin-top: 30px; padding-top: 20px; border-top: 1px solid #eee; width: 100%; }
        #hidden-work-area { position: absolute; top: -9999px; visibility: hidden; }
    </style>
</head>
<body>

<div class="container">
    <h1>Pixel æ‹¼å›¾ç”Ÿæˆå™¨ ^â€¢ï»Œâ€¢^à¸…</h1>
    
    <div class="input-group">
        <input type="text" id="numberInput" placeholder="è¾“å…¥æ•°å­— (ä¾‹å¦‚: 1024)" oninput="this.value = this.value.replace(/[^0-9]/g, '')">
        <select id="formatSelect">
            <option value="png">PNG</option>
            <option value="gif">GIF</option>
        </select>
        <button onclick="startGenerate()" id="genBtn">ç”Ÿæˆæ‹¼å›¾</button>
    </div>

    <div id="preview-area">
        <div id="imageWrapper">
            <span style="color:#ccc">ç­‰å¾…ç”Ÿæˆ...</span>
        </div>
        <div id="saveHint" class="hint">å› å®‰å…¨ç­–ç•¥æ— æ³•ç›´æ¥ä¸‹è½½, è¯·æ‹–åŠ¨æˆ–å³é”®å›¾ç‰‡â€œå¦å­˜ä¸ºâ€</div>
    </div>
    
    <div class="status" id="statusText">å‡†å¤‡å°±ç»ª</div>

    <div class="obfuscate-box">
        <h3 style="font-size: 16px; color: #555;">æ–‡æœ¬/URL é›¶å®½æ··æ·†</h3>
        <div class="input-group">
            <input type="text" id="textInput" placeholder="è¾“å…¥å†…å®¹...">
            <button style="background: #4CAF50;" onclick="obfuscateText()">æ··æ·†å¹¶å¤åˆ¶</button>
        </div>
        <div id="obfStatus" class="status" style="color: #4CAF50;"></div>
    </div>
</div>

<div id="hidden-work-area"></div>

<script src="lib/libgif.js"></script>
<script src="lib/gif.js"></script>

<script>
    const ASSETS_PNG = 'assets/danbooru/';
    const ASSETS_GIF = 'assets/gelbooru/';
    const BOM = '\ufeff'; 

    // === æ–‡æœ¬æ··æ·† ===
    function obfuscateText() {
        const input = document.getElementById('textInput').value;
        if (!input) return;
        const result = input.split('').join(BOM);
        navigator.clipboard.writeText(result).then(() => {
            const status = document.getElementById('obfStatus');
            status.innerText = "âœ… å·²å¤åˆ¶åˆ°å‰ªè´´æ¿";
            setTimeout(() => status.innerText = "", 2000);
        });
    }

    // === å›¾ç‰‡ç”Ÿæˆé€»è¾‘ ===
    async function startGenerate() {
        const text = document.getElementById('numberInput').value;
        const format = document.getElementById('formatSelect').value;
        const btn = document.getElementById('genBtn');
        const status = document.getElementById('statusText');
        const saveHint = document.getElementById('saveHint');
        const wrapper = document.getElementById('imageWrapper');

        if (!text) return alert("è¯·è¾“å…¥æ•°å­—ï¼");

        btn.disabled = true;
        saveHint.style.display = 'none';
        status.innerText = "â³ æ­£åœ¨åˆæˆä¸­ï¼Œè¯·ç¨å€™...";
        wrapper.innerHTML = '<span style="color:#ccc">æ­£åœ¨å¤„ç†...</span>';

        try {
            let blobUrl;
            if (format === 'png') {
                blobUrl = await generatePNG(text);
            } else {
                blobUrl = await generateGIF(text, status);
            }
            
            // åˆ›å»ºå›¾ç‰‡å¯¹è±¡å¹¶æ˜¾ç¤º
            const img = new Image();
            img.src = blobUrl;
            img.className = 'result';
            
            // é‡è¦ï¼šä¸ºäº†è®©å³é”®ä¿å­˜æ—¶é»˜è®¤æ–‡ä»¶åæ­£ç¡®ï¼Œè™½ç„¶åœ¨å†…å­˜ä¸­å—é™ï¼Œä½†æˆ‘ä»¬å°è¯•è®¾ç½® alt
            img.alt = `${text}.${format}`;
            img.title = `${text}.${format}`;

            wrapper.innerHTML = '';
            wrapper.appendChild(img);

            saveHint.style.display = 'block';
            status.innerText = "âœ¨ åˆæˆå®Œæ¯•";

        } catch (e) {
            console.error(e);
            status.innerText = "âŒ é”™è¯¯: " + e.message;
            wrapper.innerHTML = '<span style="color:#ff4757">åˆæˆå¤±è´¥</span>';
        } finally {
            btn.disabled = false;
        }
    }

    async function generatePNG(text) {
        const images = await Promise.all(text.split('').map(char => loadImage(`${ASSETS_PNG}${char}.png`)));
        const canvas = document.createElement('canvas');
        canvas.width = images.reduce((sum, img) => sum + img.width, 0);
        canvas.height = images[0].height;
        const ctx = canvas.getContext('2d');
        
        let x = 0;
        images.forEach(img => {
            ctx.drawImage(img, x, 0);
            x += img.width;
        });
        
        return new Promise(resolve => canvas.toBlob(blob => resolve(URL.createObjectURL(blob)), 'image/png'));
    }

    async function generateGIF(text, statusLabel) {
        statusLabel.innerText = "ğŸï¸ è§£æ GIF åºåˆ—...";
        const parsedGifs = [];
        for (let char of text) {
            const frames = await parseGifFrames(`${ASSETS_GIF}${char}.gif`);
            parsedGifs.push(frames);
        }

        const totalWidth = Math.floor(parsedGifs.reduce((a, b) => a + b[0].dims.width, 0));
        const height = Math.floor(parsedGifs[0][0].dims.height);

        const gif = new GIF({
            workers: 2,
            quality: 10,
            workerScript: 'lib/gif.worker.js',
            width: totalWidth,
            height: height
        });

        const canvas = document.createElement('canvas');
        canvas.width = totalWidth;
        canvas.height = height;
        const ctx = canvas.getContext('2d');

        const maxFrames = Math.max(...parsedGifs.map(g => g.length));
        for (let i = 0; i < maxFrames; i++) {
            ctx.clearRect(0, 0, totalWidth, height);
            let xOffset = 0;
            parsedGifs.forEach(frames => {
                const frameData = frames[i % frames.length];
                if(frameData.patch) {
                     ctx.putImageData(frameData.patch, xOffset, 0);
                }
                xOffset += frameData.dims.width;
            });
            gif.addFrame(ctx, {copy: true, delay: 200});
        }

        return new Promise((resolve) => {
            gif.on('finished', blob => resolve(URL.createObjectURL(blob)));
            gif.render();
        });
    }

    function loadImage(src) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => resolve(img);
            img.onerror = () => reject(new Error("ç´ æä¸¢å¤±: " + src));
            img.src = src;
        });
    }

    function parseGifFrames(src) {
        return new Promise((resolve) => {
            const img = document.createElement('img');
            img.src = src;
            const div = document.createElement('div');
            div.appendChild(img);
            document.getElementById('hidden-work-area').appendChild(div);
            const superGif = new SuperGif({ gif: img });
            superGif.load(() => {
                const frames = [];
                for (let i = 0; i < superGif.get_length(); i++) {
                    superGif.move_to(i);
                    const canvas = superGif.get_canvas();
                    frames.push({
                        patch: canvas.getContext('2d').getImageData(0,0, canvas.width, canvas.height),
                        dims: { width: Math.floor(canvas.width), height: Math.floor(canvas.height) }
                    });
                }
                div.remove();
                resolve(frames);
            });
        });
    }
</script>
</body>
</html>