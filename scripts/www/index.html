<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>数字转猫娘拼图 & 文本混淆</title>
    <link rel="stylesheet" href="static/style.css">
    <style>
        /* 额外补充一些混淆功能的样式，保持风格统一 */
        .obfuscate-section {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 2px dashed #eee;
        }
        .status-msg {
            font-size: 14px;
            margin-top: 10px;
            color: #4CAF50;
            display: none;
        }
        #image-preview-container {
            display: none;
        }
    </style>
</head>
<body>
<div class="container">
    <h1>数字转猫娘拼图 ^•ﻌ•^ฅ</h1>
    
    <div class="section">
        <input type="text" id="numInput" placeholder="请输入数字 (1-30位)" maxlength="30">
        <select id="formatSelect">
            <option value="png">PNG</option>
            <option value="gif">GIF</option>
        </select>
        <button type="button" onclick="handleGenerate()">生成拼图</button>
    </div>

    <div id="image-preview-container" class="result">
        <h2>生成结果</h2>
        <div id="canvas-wrapper"></div>
        <br>
        <a id="download-link" href="#" download class="download-btn">下载图片</a>
    </div>

    <div class="obfuscate-section">
        <h3>文本隐形混淆器</h3>
        <input type="text" id="textInput" style="width: 80%;" placeholder="输入链接或文本进行暴力混淆...">
        <button type="button" style="background: #2196F3;" onclick="handleObfuscate()">混淆并复制</button>
        <div id="obfuscateStatus" class="status-msg">✨ 已混淆并复制到剪贴板</div>
    </div>
</div>

<script src="lib/gif.js"></script>

<script>
    const BOM = '\ufeff'; // 零宽不换行空格

    // === 逻辑 1: 文本暴力混淆 ===
    function handleObfuscate() {
        const input = document.getElementById('textInput').value;
        if (!input) return;
        
        // 每个字符间插入零宽字符
        const obfuscated = input.split('').join(BOM);
        
        // 复制到剪贴板
        navigator.clipboard.writeText(obfuscated).then(() => {
            const status = document.getElementById('obfuscateStatus');
            status.style.display = 'block';
            setTimeout(() => { status.style.display = 'none'; }, 2000);
        });
    }

    // === 逻辑 2: 图片拼图生成 ===
    async function handleGenerate() {
        const numStr = document.getElementById('numInput').value.trim();
        const format = document.getElementById('formatSelect').value;
        const container = document.getElementById('image-preview-container');
        const wrapper = document.getElementById('canvas-wrapper');

        if (!/^\d+$/.test(numStr)) {
            alert("请输入纯数字");
            return;
        }

        wrapper.innerHTML = "正在处理...";
        container.style.display = 'block';

        try {
            if (format === 'png') {
                const dataUrl = await createPngCollage(numStr);
                displayResult(dataUrl, `collage_${numStr}.png`);
            } else {
                // GIF 逻辑
                wrapper.innerHTML = "GIF 生成中 (请稍候)...";
                const dataUrl = await createGifCollage(numStr);
                displayResult(dataUrl, `collage_${numStr}.gif`);
            }
        } catch (e) {
            wrapper.innerHTML = "生成失败，请确保 assets 目录下有对应的图片资源";
            console.error(e);
        }
    }

    function displayResult(url, filename) {
        const wrapper = document.getElementById('canvas-wrapper');
        const dlLink = document.getElementById('download-link');
        
        wrapper.innerHTML = `<img src="${url}" class="preview">`;
        dlLink.href = url;
        dlLink.download = filename;
    }

    // PNG 拼接
    async function createPngCollage(numStr) {
        const images = await Promise.all(numStr.split('').map(n => loadImage(`assets/danbooru/${n}.png`)));
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        const totalWidth = images.reduce((sum, img) => sum + img.width, 0);
        const height = images[0].height;
        
        canvas.width = totalWidth;
        canvas.height = height;
        
        let xOffset = 0;
        images.forEach(img => {
            ctx.drawImage(img, xOffset, 0);
            xOffset += img.width;
        });
        
        return canvas.toDataURL('image/png');
    }

    // GIF 拼接 (基于 gif.js)
    async function createGifCollage(numStr) {
        return new Promise(async (resolve, reject) => {
            const gif = new GIF({
                workers: 2,
                quality: 10,
                workerScript: 'lib/gif.worker.js'
            });

            const imgs = await Promise.all(numStr.split('').map(n => loadImage(`assets/gelbooru/${n}.gif`)));
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const totalWidth = imgs.reduce((sum, img) => sum + img.width, 0);
            const height = imgs[0].height;

            canvas.width = totalWidth;
            canvas.height = height;

            // 简单拼接逻辑：对于 GIF 暂时生成静态组合（前端完全解析 GIF 每一帧较为复杂）
            // 如果需要动态拼接，建议在 PakePlus 中配套引入 libgif.js 解析帧
            ctx.fillStyle = "white";
            ctx.fillRect(0,0, canvas.width, canvas.height);
            let xOffset = 0;
            imgs.forEach(img => {
                ctx.drawImage(img, xOffset, 0);
                xOffset += img.width;
            });

            gif.addFrame(ctx, {copy: true, delay: 200});
            gif.on('finished', function(blob) {
                resolve(URL.createObjectURL(blob));
            });
            gif.render();
        });
    }

    function loadImage(src) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => resolve(img);
            img.onerror = reject;
            img.src = src;
        });
    }
</script>
</body>
</html>